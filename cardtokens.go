package main

import (
	"fmt"

	"github.com/cardtokens/demo-cardtokens-golang/helper"
)

//
// The Cardtokens generated public key base64 encoded for this example
//
const PUBLIC_KEY_PEM string = "LS0tLS1CRUdJTiBQVUJMSUMgS0VZLS0tLS0NCk1JSUNJakFOQmdrcWhraUc5dzBCQVFFRkFBT0NBZzhBTUlJQ0NnS0NBZ0VBMW1zdE1QckZSVmQ4VE1HclkzMjQNCjJwcTQ2aFlFMFBieXcrTnB0MnRDSjBpRHkrWkxQWWJGMnVYTkg1UE9neGkzdDVIVTY2MVVTQThYOXp5N2pJTzANCjlpOGxRMkdoN1dpejlqZXpFVDBpVmNvUGovSFFrV1N1KzA5Y0RIUk5qUDJoaWtIWUEwOUlZc05vemo3eHR2ME4NCnJxbjZacWZ5amhOS1NrN2RUeUVVQ0xoaEwvTUVFRTZ0QUREVVJZb0tIVXFrVml0cFlzcE1HamlKNkFBSVlVZWENCk1DdkZ2cnhaSkFNSW5FbnY3THNhTHVBV21pdzRrOXM5M0x1MXdoM3A1bjR1a09pVWpRWEZ5Nm9NNzMwblpvb1MNCmR2U2lYUlR2UlFwMDkyZDAzbnY5Zk55cWgwM3ZoM2l5TFJja3RoVnc2ZklPN3p4cktjTXpoVmhzK3doUGVtMzkNCkRhU05oSjFrZUx4bzcyaDJIL01FMzRuQzNOSUhCUEhQZ1NBeHVDSjlCcXVVRW1idXdGMTc0eDlGOUhFYm5jRlkNClRTd1hmS3diN1cxZ0F1U1RlWmhKVXc1eDZ6a3ZUTmRTejRWaFFjT051SjJ6am1VdGdSK3FXc1NjOUh2N1RGREgNCjlQbCt5NmQxeVJ0Rmp2TmlqeGZQUmo5a1dKbVJvcnBVVExUMTh2dThlbzg1aWNLTVY1VmladDMweGxpc1RVTjANCjJOWkxjNG83TVdraHE1eGhGcXhmZDdTZXZEc1FLa0VpenlRbi9zOUpZNmsybEtQUG4wTXk1UjdURWtBZEhVREUNCklIc09qTXlrZnpwYVdoNldMK2RmRlRFVzE4MFNkRHdXbEFXaWtpYWhFT1NDRGVFMkpWTDluMjY3QzJkc0ZJZDYNCjVPczJKVjE5anl5b2VGQkhOQm11MFBjQ0F3RUFBUT09DQotLS0tLUVORCBQVUJMSUMgS0VZLS0tLS0NCg=="

//
// Test merchantid from Cardtokens
//
const MERCHANTID string = "523ca9d5eb9d4ce0a60b2a3f5eb3119d"

//
// The apikey to authenticate the Cardtokens API
//
const APIKEY string = "95f734793a424ea4ae8d9dc0b8c1a4d7"

//
// The end points to the Cardtokens API
//
const API_ENDPOINT string = "https://api.cardtokens.io"

func main() {
	// Variables for storing values
	var mValue interface{}
	var token string = ""
	var tokenid string = ""
	var cryptogram string = ""
	var status string = ""

	//
	// Maps for storing request and response data
	//
	mRequest := make(map[string]string, 0)
	mResponse := make(map[string]interface{}, 0)
	mCard := make(map[string]interface{})

	//
	// Test card details
	//
	mCard["pan"] = "4111111145551142"
	mCard["expmonth"] = "6"
	mCard["expyear"] = "2029"
	mCard["securitycode"] = "000"

	//
	// Generate encrypted request and use the public key generated by Cardtokens
	//
	err, enccard := helper.GenerateEncryptedRequest(mCard, PUBLIC_KEY_PEM)
	if err != nil {
		panic(err)
	}

	//
	// Set request parameters where enccard is sset with the encrypted card object which
	// includes pan, expmonth, expyear and securitycode
	//
	mRequest["enccard"] = enccard
	mRequest["merchantid"] = MERCHANTID

	//
	// Send request to Cardtokens
	//
	err, mResponse = helper.RequestCardtokens("POST", API_ENDPOINT+"/api/token", mRequest, APIKEY)
	if err != nil {
		fmt.Println("Unable to request... " + err.Error())
		return
	}

	//
	// Get tokenid from response
	//
	if mValue, err = helper.GetMapValueSafe(mResponse, "tokenid", "string"); err != nil {
		fmt.Println("Unable to fetch tokenid: " + err.Error())
		return
	}
	tokenid = mValue.(string)

	//
	// Get token from response
	//
	if mValue, err = helper.GetMapValueSafe(mResponse, "token", "string"); err != nil {
		fmt.Println("Unable to fetch tokenid: " + err.Error())
		return
	}
	token = mValue.(string)

	//
	// Print token details
	//
	fmt.Println("Created token with Cardtokens tokenid: " + tokenid + " and scheme token: " + token)

	//
	// Reset request and response maps
	//
	mRequest = make(map[string]string, 0)
	mResponse = make(map[string]interface{}, 0)

	//
	// Set the request parameters for cryptogram
	//
	mRequest["reference"] = "cardtokens-123"
	mRequest["transactiontype"] = "ecom"
	mRequest["unpredictablenumber"] = "87654321"

	//
	// Send the request for cryptogram
	//
	err, mResponse = helper.RequestCardtokens("POST", API_ENDPOINT+"/api/token/"+tokenid+"/cryptogram", mRequest, APIKEY)
	if err != nil {
		fmt.Println("Unable to request for cryptogram... " + err.Error())
		return
	}

	//
	// Get cryptogram from response
	//
	if mValue, err = helper.GetMapValueSafe(mResponse, "cryptogram", "string"); err != nil {
		fmt.Println("Unable to fetch cryptogram: " + err.Error())
		return
	}
	cryptogram = mValue.(string)

	//
	// Print cryptogram
	//
	fmt.Println("Created cryptogram: " + cryptogram)

	//
	// Reset request and response maps
	//
	mResponse = make(map[string]interface{}, 0)

	//
	// Send the request for token status
	//
	err, mResponse = helper.RequestCardtokens("GET", API_ENDPOINT+"/api/token/"+tokenid+"/status", nil, APIKEY)
	if err != nil {
		fmt.Println("Unable to request... " + err.Error())
		return
	}

	//
	// Get token status from response
	//
	if mValue, err = helper.GetMapValueSafe(mResponse, "status", "string"); err != nil {
		fmt.Println("Unable to fetch cryptogram: " + err.Error())
		return
	}
	status = mValue.(string)

	//
	// Print token status
	//
	fmt.Println("Token has status: " + status)

	//
	// Send the request to delete the token
	//
	err, _ = helper.RequestCardtokens("DELETE", API_ENDPOINT+"/api/token/"+tokenid+"/delete", nil, APIKEY)
	if err != nil {
		fmt.Println("Unable to request to delete the token... " + err.Error())
		return
	}

	//
	// Print deletion message
	//
	fmt.Println("Token is deleted")
}
